'use strict';

var stringify = require('json-stable-stringify');

var _require = require('./hash.js'),
    getBlockHash = _require.getBlockHash,
    getValidatorSetHash = _require.getValidatorSetHash;

var getValidatorAddress = require('./address.js');

var ed25519 = require('supercop.js');
try {
  // try to load native version
  ed25519 = require('ed25519-supercop');
} catch (err) {}

// gets the serialized representation of a vote, which is used
// in the commit signatures
function getVoteSignBytes(chain_id, vote) {
  var block_id = vote.block_id,
      height = vote.height,
      round = vote.round,
      type = vote.type,
      timestamp = vote.timestamp;

  // normalize time zone

  timestamp = new Date(timestamp).toISOString();

  return stringify({
    chain_id: chain_id,
    vote: { block_id: block_id, height: height, round: round, type: type, timestamp: timestamp }
  });
}

// verifies that a number is a positive integer, less than the
// maximum safe JS integer
function verifyPositiveInt(n) {
  if (!Number.isInteger(n)) {
    throw Error('Value must be an integer');
  }
  if (n > Number.MAX_SAFE_INTEGER) {
    throw Error('Value must be < 2^53');
  }
  if (n < 0) {
    throw Error('Value must be >= 0');
  }
}

// verifies a commit signs the given header, with 2/3+ of
// the voting power from given validator set
function verifyCommit(header, commit, validators) {
  var blockHash = getBlockHash(header);

  if (blockHash !== commit.blockID.hash) {
    throw Error('Commit does not match block hash');
  }

  var countedValidators = new Array(validators.length);
  var roundNumber = void 0;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = commit.precommits[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var precommit = _step.value;

      // skip empty precommits
      if (precommit == null) continue;

      // all fields of block ID must match commit
      if (precommit.block_id.hash !== commit.blockID.hash) {
        throw Error('Precommit block hash does not match commit');
      }
      if (precommit.block_id.parts.total !== commit.blockID.parts.total) {
        throw Error('Precommit parts count does not match commit');
      }
      if (precommit.block_id.parts.hash !== commit.blockID.parts.hash) {
        throw Error('Precommit parts hash does not match commit');
      }

      // height must match header
      if (precommit.height !== header.height) {
        throw Error('Precommit height does not match header');
      }

      // rounds of all precommits must match
      verifyPositiveInt(precommit.round);
      if (roundNumber == null) {
        roundNumber = precommit.round;
      } else if (precommit.round !== roundNumber) {
        throw Error('Precommit rounds do not match');
      }

      // vote type must be 2 (precommit)
      if (precommit.type !== 2) {
        throw Error('Precommit has invalid type value');
      }

      // ensure there are never multiple precommits from a single validator
      if (countedValidators[precommit.validator_index]) {
        throw Error('Validator has multiple precommits');
      }
      countedValidators[precommit.validator_index] = true;

      // ensure this precommit references the correct validator
      var validator = validators[precommit.validator_index];
      if (precommit.validator_address !== getValidatorAddress(validator.pub_key)) {
        throw Error('Precommit address does not match validator');
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  verifyCommitSigs(header, commit, validators);
}

// verifies a commit is signed by at least 2/3+ of the voting
// power of the given validator set
function verifyCommitSigs(header, commit, validators) {
  var committedVotingPower = 0;
  var countedValidators = new Array(validators.length);

  // index validators by address
  var validatorsByAddress = {};
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = validators[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var validator = _step2.value;

      validatorsByAddress[validator.address] = validator;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = commit.precommits[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var precommit = _step3.value;

      // skip empty precommits
      if (precommit == null) continue;

      var _validator = validatorsByAddress[precommit.validator_address];

      // skip if this validator isn't in the set
      // (we allow precommits from validators not in the set,
      // because we sometimes check the commit against older
      // validator sets)
      if (!_validator) continue;

      var signature = Buffer.from(precommit.signature.data, 'hex');
      var signBytes = Buffer.from(getVoteSignBytes(header.chain_id, precommit));
      var pubKey = Buffer.from(_validator.pub_key.data, 'hex');

      // TODO: support secp256k1 sigs
      if (!ed25519.verify(signature, signBytes, pubKey)) {
        throw Error('Invalid precommit signature');
      }

      // count this validator's voting power
      committedVotingPower += _validator.voting_power;
    }

    // sum all validators' voting power
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var totalVotingPower = validators.reduce(function (sum, v) {
    return sum + v.voting_power;
  }, 0);
  // JS numbers have no loss of precision up to 2^53, but we
  // error at over 2^52 since we have to do arithmetic. apps
  // should be able to keep voting power lower than this anyway
  if (totalVotingPower > 2 ** 52) {
    throw Error('Total voting power must be less than 2^52');
  }

  // verify enough voting power signed
  var twoThirds = Math.ceil(totalVotingPower * 2 / 3);
  if (committedVotingPower < twoThirds) {
    throw Error('Not enough committed voting power');
  }
}

// verifies that a validator set is in the correct format
// and hashes to the correct value
function verifyValidatorSet(validators, expectedHash) {
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = validators[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var validator = _step4.value;

      if (getValidatorAddress(validator.pub_key) !== validator.address) {
        throw Error('Validator address does not match pubkey');
      }

      verifyPositiveInt(validator.voting_power);
      if (validator.voting_power === 0) {
        throw Error('Validator voting power must be > 0');
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  var validatorSetHash = getValidatorSetHash(validators);
  if (validatorSetHash !== expectedHash) {
    throw Error('Validator set does not match what we expected');
  }
}

// verifies transition from one block to a higher one, given
// each block's header, commit, and validator set
function verify(oldState, newState) {
  if (newState.header.chain_id !== oldState.header.chain_id) {
    throw Error('Chain IDs do not match');
  }
  if (newState.header.height <= oldState.header.height) {
    throw Error('New state height must be higher than old state height');
  }

  var validatorSetChanged = newState.header.validators_hash !== oldState.header.validators_hash;

  // make sure new header has a valid commit
  var validators = validatorSetChanged ? newState.validators : oldState.validators;
  verifyCommit(newState.header, newState.commit, validators);

  if (validatorSetChanged) {
    // make sure new validator set has correct hash
    verifyValidatorSet(newState.validators, newState.header.validators_hash);

    // make sure new commit is signed by 2/3+ of old validator set
    verifyCommitSigs(newState.header, newState.commit, oldState.validators);
  }
}

module.exports = verify;
Object.assign(module.exports, {
  verifyCommit: verifyCommit,
  verifyCommitSigs: verifyCommitSigs,
  verifyValidatorSet: verifyValidatorSet,
  verify: verify
});